---
layout: post
title: 백준 A + B
subtitle: [TIL01 1000번]
thumbnail-img: ../images/algorithm.png
tags: [TIL, 알고리즘, C]
comments: true
---
## 문제  

A와 B를 입력 받아, A + B를 출력하는 문제이다.  

문제를 예상보다 빨리 풀게 되어 코드 골프를 도전하게 되었다.  
<br>

## 로직
```c
int main(){int a,b;scanf("%d%d",&a,&b);printf("%d",a+b);}
```  
이런 식으로 작성했다. 나름 잘 짠 줄 알았다.  
<br>

근데 다른 사람들 코드 보니까 바이트 수가 내 코드의 절반 밖에 되지 않길래 한참을 고민하다가 실패했다.  

결국 구글링을 통해 답을 찾게 되었다.  
<br>

```c
main(n){gets(&n);printf("%d",n%85-43);}
```  
<br>

우선 이 코드를 보자마자, 이게 어떻게 A + B를 출력하지? 라는 생각을 먼저 했다.  

이해하고 싶어서 구글에 저 코드를 그대로 쳤더니 나와 비슷한 고민을 하신 분들이 꽤 있었다.  
<br>

- main의 반환 타입  
	main 함수에서 반환 타입을 생략할 경우, 디폴트 값인 int 타입으로 지정돤다.  

- main의 인자  
	main 함수의 인자 'n'의 선언을 생략할 경우, 이것 또한 디폴트 값인 int 타입으로 지정된다.  

- gets()  
	```c
	#include <stdio.h>
	char *gets(char *buffer);
	```  
	gets함수의 프로토타입이다.  
	반환 값과 인자 모두 포인터 char형이다.  

- 값 저장  
	리틀엔디안 방식으로 n에 1 바이트 씩 값들을 저장한다.  
	(A * 256^0) + (공백문자 * 256^1) + (B * 256^2) + '\0' 이런 식으로 저장된다고 한다.  

- 숫자 출력  
	(n % 85) - 43 식의 이유는 리틀엔디언 방식으로 저장된 문자를 정수로 변환하기 위해 사용하는 식이다.  

여튼 A + B 하나를 출력하는데 이런 식이 나올 수 있다는 것을 보고 놀라웠다.  
코드 골프는 재미로 해야겠다.  
<br>

## 링크

https://www.acmicpc.net/problem/1000